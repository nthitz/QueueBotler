// Generated by CoffeeScript 1.3.3
(function() {
  var $, ChatManager, DEBUG, PMManager, PinManager, TTAPI, addToQueue, addToQueueIfNotInQueue, adminIDs, bot, chatModeOnFor, checkForIdleUsers, checkIn, devMode, doQueueActionIfInQueue, getQueueMessages, host, http, init, lastIdleUserCheck, latestQueue, makeNameQueueSafe, masterPin, masterPinEnabled, masterPinRemove, numberToEmoji, parsePM, pmHelp, processQueueHTML, profiles, querystring, queueLineID, redis, redisClient, removeIdleUsers, removeQueuedPerson, requestPin, requestPinArray, requestQueue, savePin, savePinInQueue, sendQueueInChat, sendQueueInChatIfVerified, sendQueueInPM, updateStatus, util;

  http = require('http');

  $ = require('jquery');

  querystring = require('querystring');

  TTAPI = require('ttapi');

  profiles = require('./UserProfiles');

  PMManager = require('./PMManager');

  ChatManager = require('./ChatManager');

  PinManager = require('./PinManager');

  util = require('util');

  redis = require('redis');

  DEBUG = false;

  host = 'www.sosimpull.com';

  latestQueue = null;

  queueLineID = 0;

  adminIDs = ["4f50f403590ca262030050e7"];

  devMode = false;

  bot = null;

  redisClient = null;

  chatModeOnFor = [];

  lastIdleUserCheck = new Date().getTime();

  masterPin = process.env.MASTERPIN;

  masterPinEnabled = typeof masterPin !== 'undefined';

  checkForIdleUsers = function(queue) {
    var curTime, doCheck, idleCheckEvery;
    doCheck = false;
    if (lastIdleUserCheck === null) {
      doCheck = true;
      lastIdleUserCheck = new Date().getTime();
    } else {
      curTime = new Date().getTime();
      idleCheckEvery = 60;
      if (curTime - lastIdleUserCheck > idleCheckEvery) {
        doCheck = true;
        lastIdleUserCheck = curTime;
      }
    }
    if (!doCheck) {
      return;
    }
    return redisClient.keys("PIN*", function(err, data) {
      var allPins, pin, userid, _i, _len;
      allPins = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        pin = data[_i];
        userid = pin.substr(4);
        allPins.push(userid);
      }
      return requestPinArray(allPins, removeIdleUsers, queue);
    });
  };

  requestPinArray = function(pins, cb, arg1) {
    return requestPin(pins, [], cb, arg1);
  };

  requestPin = function(pinList, pinStorage, cb, arg1) {
    if (pinList.length === pinStorage.length) {
      pinList = null;
      cb(pinStorage, arg1);
      return;
    }
    return PinManager.get(pinList[pinStorage.length], function(err, pin) {
      if (pin !== null) {
        pin.userid = pinList[pinStorage.length];
      }
      pinStorage.push(pin);
      return requestPin(pinList, pinStorage, cb, arg1);
    });
  };

  removeIdleUsers = function(pins, queue) {
    var idleTime, idleUser, idleUsers, mins, pin, pinO, queuePerson, timeParts, validLineID, validLineIDs, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m;
    validLineIDs = [];
    for (_i = 0, _len = pins.length; _i < _len; _i++) {
      pin = pins[_i];
      if (pin === null) {
        continue;
      }
      validLineID = false;
      for (_j = 0, _len1 = queue.length; _j < _len1; _j++) {
        queuePerson = queue[_j];
        if (queuePerson.lineID === pin.lineID) {
          validLineID = true;
          break;
        }
      }
      if (!validLineID) {
        PinManager.del(pin.userid);
      } else {
        validLineIDs.push(pin.lineID);
      }
    }
    idleTime = 120;
    idleUsers = [];
    for (_k = 0, _len2 = queue.length; _k < _len2; _k++) {
      queuePerson = queue[_k];
      timeParts = queuePerson.time.split(' ');
      mins = parseInt(timeParts[0]);
      if (mins >= idleTime) {
        idleUsers.push(queuePerson);
      }
    }
    for (_l = 0, _len3 = idleUsers.length; _l < _len3; _l++) {
      idleUser = idleUsers[_l];
      if (validLineIDs.indexOf(idleUser.lineID) !== -1) {
        if (pins.length > 0) {
          pinO = null;
          for (_m = 0, _len4 = pins.length; _m < _len4; _m++) {
            pin = pins[_m];
            if (pin.lineID === idleUser.lineID) {
              pinO = pin;
              break;
            }
          }
          if (pinO === null) {
            console.error('couldn\'t find pin?');
            continue;
          }
          removeQueuedPerson(idleUser, pinO);
        }
      } else if (masterPinEnabled) {
        masterPinRemove(idleUser.lineID);
      }
    }
    pins = null;
    return queue = null;
  };

  requestQueue = function(callback) {
    var cb, queueOptions, req;
    queueOptions = {
      host: host,
      path: '/line.php'
    };
    cb = function(response) {
      var str;
      str = '';
      response.on('data', function(data) {
        return str += data;
      });
      return response.on('end', function() {
        return processQueueHTML(str, callback);
      });
    };
    req = http.request(queueOptions, cb);
    return req.end();
  };

  processQueueHTML = function(html, callback) {
    var $h, curQ, item, lineID, name, status, tds, time, tr, trs, _i, _len;
    $h = $(html);
    trs = $h.find('tbody').find('tr');
    curQ = [];
    for (_i = 0, _len = trs.length; _i < _len; _i++) {
      tr = trs[_i];
      tds = $(tr).find('td');
      name = $(tds[1]).text();
      time = $(tds[2]).text();
      status = $(tds[6]).find('select').val();
      lineID = $(tds[6]).find('select').attr('id').substr(7);
      item = {
        name: name,
        time: time,
        status: status,
        lineID: lineID
      };
      curQ.push(item);
    }
    checkForIdleUsers(curQ);
    latestQueue = curQ;
    return callback(curQ);
  };

  getQueueMessages = function(queue) {
    var index, lineNum, msgs, pMsg, person;
    msgs = [];
    msgs.push('Current Queue from http://sosimpull.com/mashupfm-line/');
    lineNum = 0;
    if (queue.length !== 0) {
      for (index in queue) {
        person = queue[index];
        lineNum++;
        pMsg = numberToEmoji(lineNum) + ' ';
        pMsg += person.name.charAt(0) === '@' ? '' : '@';
        pMsg += person.name;
        pMsg += ' (' + person.time;
        if (person.status !== 'Here') {
          pMsg += ', ' + person.status;
        }
        pMsg += ')';
        msgs.push(pMsg);
      }
    } else {
      msgs.push("Empty!");
    }
    return msgs;
  };

  sendQueueInPM = function(queue, user) {
    var msgs;
    msgs = getQueueMessages(queue);
    return PMManager.queuePMs(msgs, user.userid);
  };

  sendQueueInChatIfVerified = function(user) {
    return bot.roomInfo(false, function(data) {
      var verified;
      verified = false;
      if (data.room.metadata.moderator_id.indexOf(user.userid) !== -1) {
        verified = true;
      }
      if (data.room.metadata.djs.indexOf(user.userid) !== -1) {
        verified = true;
      }
      if (adminIDs.indexOf(user.userid) !== -1) {
        verified = true;
      }
      if (verified) {
        return requestQueue(function(queue) {
          return sendQueueInChat(queue);
        });
      } else {
        return PMManager.queuePMs(["Sorry I can't let you do that."], user.userid);
      }
    });
  };

  sendQueueInChat = function(queue) {
    var msgs;
    msgs = getQueueMessages(queue);
    return ChatManager.sendChat(msgs);
  };

  numberToEmoji = function(num) {
    switch (num) {
      case 1:
        return ":one:";
      case 2:
        return ":two:";
      case 3:
        return ":three:";
      case 4:
        return ":four:";
      case 5:
        return ":five:";
      case 6:
        return ":six:";
      case 7:
        return ":seven:";
      case 8:
        return ":eight:";
      case 9:
        return ":nine:";
      default:
        return num + ":";
    }
  };

  makeNameQueueSafe = function(name) {
    name = name.replace(/'/g, "");
    return name;
  };

  addToQueueIfNotInQueue = function(queue, user) {
    /*
    	if we have pin
    		get current queue
    		for each in q
    			if line id matches
    				pm already in the queue
    		no matches
    			remove pin from pin manager
    			add them to queue
    	no pin
    		add them to queue
    */
    return PinManager.get(user.userid, function(err, pin) {
      if (pin !== null) {
        return requestQueue(function(queue) {
          var queuePerson, username, _i, _len;
          username = makeNameQueueSafe(user.name);
          for (_i = 0, _len = queue.length; _i < _len; _i++) {
            queuePerson = queue[_i];
            if (queuePerson.lineID === pin.lineID) {
              PMManager.queuePMs(["It looks like you are already in the queue!"], user.userid);
              return;
            } else if (queuePerson.name === username) {
              PMManager.queuePMs(["Someone with your name exists in the queue, but it was not added through me.", "Remove it and you can add through me."], user.userid);
              return;
            }
          }
          return PinManager.del(user.userid, function() {
            return addToQueue(user);
          });
        });
      } else {
        return addToQueue(user);
      }
    });
    /*
    	username = makeNameQueueSafe(user.name)
    	for person in queue
    		if person.name is username
    			PMManager.queuePMs ["You are already in the queue."], user.userid
    			return false
    	addToQueue(user)
    */

  };

  savePinInQueue = function(queue, pin, user) {
    var person, queueName, _i, _len, _results;
    queueName = makeNameQueueSafe(user.name);
    _results = [];
    for (_i = 0, _len = queue.length; _i < _len; _i++) {
      person = queue[_i];
      if (person.name === queueName) {
        savePin(person.lineID, pin, user.userid);
        break;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  savePin = function(lineID, pin, userid) {
    var pinO;
    pinO = {
      lineID: lineID,
      pin: pin
    };
    return PinManager.set(userid, pinO);
  };

  addToQueue = function(user) {
    var addData, cb, pin, queueName, queueOptions, req, strPin;
    pin = Math.floor(Math.random() * 1000);
    strPin = "" + pin;
    if (pin < 100) {
      strPin = Math.floor(Math.random() * 10) + strPin;
    }
    if (pin < 10) {
      strPin = Math.floor(Math.random() * 10) + strPin;
    }
    queueName = makeNameQueueSafe(user.name);
    queueName = queueName.replace(/\\/g, "\\\\");
    addData = querystring.stringify({
      whichLine: queueLineID,
      lineName: queueName,
      linePIN: strPin,
      Add: 'Add'
    });
    queueOptions = {
      host: host,
      path: '/lineProcess.php',
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Content-Length': addData.length
      }
    };
    cb = function(response) {
      var str;
      response.setEncoding('utf8');
      str = '';
      response.on('data', function(data) {
        return str += data;
      });
      return response.on('end', function() {
        var msg;
        requestQueue(function(q) {
          return savePinInQueue(q, strPin, user);
        });
        msg = "You have been added to the queue, your pin is " + strPin + ". Estimated position in line #" + (latestQueue.length + 1);
        return PMManager.queuePMs([msg], user.userid);
      });
    };
    req = http.request(queueOptions, cb);
    console.log(addData);
    req.write(addData);
    return req.end();
  };

  doQueueActionIfInQueue = function(user, action, pmOnFail, arg1) {
    if (pmOnFail == null) {
      pmOnFail = false;
    }
    return PinManager.get(user.userid, function(error, pin) {
      if (pin === null) {
        if (pmOnFail) {
          PMManager.queuePMs(["Sorry, it does not seem like you added through me. [1]"], user.userid);
        }
        return;
      }
      return requestQueue(function(queue) {
        var queuePerson, _i, _len;
        for (_i = 0, _len = queue.length; _i < _len; _i++) {
          queuePerson = queue[_i];
          if (queuePerson.lineID === pin.lineID) {
            action(queuePerson, user, arg1);
            return;
          }
        }
        if (pmOnFail) {
          PMManager.queuePMs(["Sorry, it does not seem like you added through me. [2]"], user.userid);
          return PinManager.del(user.userid);
        }
      });
    });
  };

  masterPinRemove = function(lineID) {
    var cb, queueOptions;
    queueOptions = {
      host: host,
      path: '/lineDeleteProcess.php?lineID=' + lineID + '&linePIN=' + masterPin + "&whichLine=" + queueLineID
    };
    console.log('removing ' + lineID + ' with master pin');
    cb = function(response) {
      var str;
      response.setEncoding('utf8');
      str = '';
      response.on('data', function(data) {
        return str += data;
      });
      return response.on('end', function() {
        var msg;
        return msg = "You have been removed from the queue.";
      });
    };
    return http.request(queueOptions, cb).end();
  };

  removeQueuedPerson = function(queuePerson, user) {
    return PinManager.get(user.userid, function(error, pin) {
      var cb, queueOptions;
      if (pin === null) {
        PMManager.queuePMs(["Sorry, I do not know your PIN."], user.userid);
        return;
      }
      queueOptions = {
        host: host,
        path: '/lineDeleteProcess.php?lineID=' + queuePerson.lineID + '&linePIN=' + pin.pin + "&whichLine=" + queueLineID
      };
      console.log(queueOptions.path);
      cb = function(response) {
        var str;
        response.setEncoding('utf8');
        str = '';
        response.on('data', function(data) {
          return str += data;
        });
        return response.on('end', function() {
          var msg;
          msg = "You have been removed from the queue.";
          PinManager.del(user.userid);
          return PMManager.queuePMs([msg], user.userid);
        });
      };
      return http.request(queueOptions, cb).end();
    });
  };

  updateStatus = function(queuePerson, user, status) {
    var oldStatus;
    oldStatus = status.toLowerCase();
    if (oldStatus === 'bathroom') {
      oldStatus = 'restroom';
    }
    status = oldStatus.charAt(0).toUpperCase() + oldStatus.slice(1);
    return PinManager.get(user.userid, function(error, pin) {
      var cb, reqOpts;
      if (pin === null) {
        PMManager.queuePMs(['Sorry, I do not know your PIN.'], user.userid);
        return;
      }
      reqOpts = {
        host: host,
        path: '/lineCheckInProcess.php?lineID=' + queuePerson.lineID + '&linePIN=' + pin.pin + '&whichLine=' + queueLineID + '&lineStatus=' + status
      };
      console.log(reqOpts.path);
      cb = function(response) {
        var str;
        response.setEncoding('utf8');
        str = '';
        response.on('data', function(data) {
          return str += data;
        });
        return response.on('end', function() {
          var msg;
          msg = "Your status has been updated to: " + status;
          return PMManager.queuePMs([msg], user.userid);
        });
      };
      return http.request(reqOpts, cb).end();
    });
  };

  checkIn = function(queuePerson, user) {
    return PinManager.get(user.userid, function(error, pin) {
      var cb, queueOptions;
      if (pin === null) {
        PMManager.queuePMs(["Sorry, I do not know your PIN."], user.userid);
        return;
      }
      queueOptions = {
        host: host,
        path: '/lineCheckInProcess.php?lineID=' + queuePerson.lineID + '&linePIN=' + pin.pin + "&whichLine=" + queueLineID
      };
      console.log(queueOptions.path);
      cb = function(response) {
        var str;
        response.setEncoding('utf8');
        str = '';
        response.on('data', function(data) {
          return str += data;
        });
        return response.on('end', function() {
          var msg;
          msg = "You've been checked in";
          return PMManager.queuePMs([msg], user.userid);
        });
      };
      return http.request(queueOptions, cb).end();
    });
  };

  parsePM = function(pm, user) {
    var originalText;
    originalText = pm.text;
    pm.text = pm.text.toLowerCase().trim();
    if (devMode) {
      if (adminIDs.indexOf(user.userid) === -1) {
        PMManager.queuePMs(["I'm currently offline while @nthitz rewires my circuits. Please goto http://sosimpull.com/mashupfm-line/ to join the queue!"], user.userid);
        return;
      }
    }
    if (pm.text === '=chatmodeoff') {
      delete chatModeOnFor[user.userid];
      PMManager.queuePMs([":("], user.userid);
    } else if (typeof chatModeOnFor[user.userid] !== 'undefined') {
      ChatManager.sendChat([originalText]);
    } else if (pm.text === 'q chat' || pm.text === 'queue chat') {
      sendQueueInChatIfVerified(user);
    } else if (pm.text === 'add' || pm.text === 'a') {
      requestQueue(function(queue) {
        return addToQueueIfNotInQueue(queue, user);
      });
    } else if (pm.text === 'rm' || pm.text === 'r' || pm.text === 'remove') {
      doQueueActionIfInQueue(user, removeQueuedPerson, true);
    } else if (pm.text === 'c' || pm.text === 'ci' || pm.text === 'checkin' || pm.text === 'check in') {
      doQueueActionIfInQueue(user, checkIn, true);
    } else if (pm.text === 'q' || pm.text === 'queue') {
      requestQueue(function(queue) {
        return sendQueueInPM(queue, user);
      });
    } else if (pm.text === 'lunch' || pm.text === 'meeting' || pm.text === 'restroom' || pm.text === 'bathroom' || pm.text === 'here') {
      doQueueActionIfInQueue(user, updateStatus, true, pm.text);
    } else if (pm.text === '=chatmodeon') {
      if (adminIDs.indexOf(user.userid !== -1)) {
        chatModeOnFor[user.userid] = true;
        PMManager.queuePMs([":)"], user.userid);
      }
    } else if (pm.text === 'help') {
      pmHelp("help", user.userid);
    } else if (pm.text === 'about') {
      pmHelp('about', user.userid);
    } else if (pm.text === 'status' || pm.text === 'help status') {
      pmHelp('status', user.userid);
    } else if (pm.text === 'help add') {
      pmHelp("add", user.userid);
    } else if (pm.text === 'help remove') {
      pmHelp('remove', user.userid);
    } else if (pm.text === 'help checkin') {
      pmHelp('checkin', user.userid);
    } else if (pm.text === 'help queue') {
      pmHelp('queue', user.userid);
    } else if (pm.text === 'help about') {
      pmHelp('about', user.userid);
    } else {
      PMManager.queuePMs(["Sorry I don't know what you mean. PM me \"help\" for info."], user.userid);
    }
    return console.log("pm: " + user.name + ": " + pm.text);
  };

  pmHelp = function(msg, userid) {
    var msgs;
    msgs = [];
    if (msg === "help") {
      msgs = ["Hello, I'm QueueBotler for the mashup.fm line @ http://sosimpull.com/mashupfm-line/. I work through PRIVATE MESSAGES NOT CHAT! Here are some commands: add, remove, checkin, queue, about, status. PM \"help [command]\" for more info on any command"];
    } else if (msg === 'add') {
      msgs = ["add: adds you to the sosimpull.com queue", "aliases: add, a"];
    } else if (msg === "remove") {
      msgs = ["remove: removes you from the sosimpull.com queue", "only works if you added with the bot", "aliases: remove, rm, r"];
    } else if (msg === "checkin") {
      msgs = ["checkin: checks you in to the sosimpull.com queue", "only works if you added with the bot", "aliases: checkin, check in, ci, c"];
    } else if (msg === "queue") {
      msgs = ["queue: pms you the current queue", "aliases: queue, q", "if you are a mod or on deck you can append 'chat' to send the queue to the chat ex: \"q chat\""];
    } else if (msg === 'about') {
      msgs = ["Real line here: http://sosimpull.com/mashupfm-line/", "Facebook Group http://www.facebook.com/groups/mashupfm/", "Rules http://bit.ly/TLBLyC", "Created by @nthitz - nthtiz AT gmail DOT com"];
    } else if (msg === 'status') {
      msgs = ["To change your status, pm me one of the following: lunch, meeting, restroom or here"];
    }
    return PMManager.queuePMs(msgs, userid);
  };

  init = function() {
    var rtg;
    if (typeof process.env.AUTH === 'undefined') {
      console.log('setup bot environmnet vars first');
      process.exit();
    }
    if (typeof process.env.REDISURL === 'undefined') {
      console.log('need redis url');
      process.exit();
    }
    rtg = require("url").parse(process.env.REDISURL);
    redisClient = redis.createClient(rtg.port, rtg.hostname);
    redisClient.auth(rtg.auth.split(":")[1], redis.print);
    PinManager.init(redisClient);
    bot = new TTAPI(process.env.AUTH, process.env.USERID);
    profiles.init(bot);
    PMManager.setBot(bot);
    ChatManager.setBot(bot);
    bot.on('ready', function(data) {
      return bot.roomRegister(process.env.ROOMID);
    });
    bot.on('speak', function(data) {
      var lower;
      lower = data.text.toLowerCase().trim();
      if (lower.match(/^\/?\+?q(ueue)?\+?$/)) {
        return pmHelp("help", data.userid);
      }
    });
    bot.on('pmmed', function(data) {
      return profiles.getProfile(data.senderid, function(profile) {
        return parsePM(data, profile);
      });
    });
    bot.on('add_dj', function(data) {
      return doQueueActionIfInQueue(data.user[0], function(queuePerson, user) {
        return PMManager.queuePMs(["If you are staying up on stage, you will be auto-removed from the queue once you start playing your song."], data.user[0].userid);
      }, false);
    });
    return bot.on('newsong', function(data) {
      var userO;
      userO = {
        userid: data.room.metadata.current_dj
      };
      return doQueueActionIfInQueue(userO, removeQueuedPerson, false);
    });
  };

  init();

}).call(this);
